// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;

namespace AssemblyCSharp
{
	public class MazeData
	{
		public const int MAX_SCORE = 4;
		public uint movesQuota;
		
		public int width { get { return _width; } }

		public int height { get { return _height; } }
		
		private int _width;
		private int _height;
		private NodeData[] _data;
		private System.Random _rnd;

		public MazeData (int width, int height)
		{
			_rnd = new System.Random ();

			_width = width;
			_height = height;
			
			_data = new NodeData[_width * _height];
			
			for (int j = 0; j < _width; j++)
				for (int i = 0; i < _height; i++)
					_data [i + j * _width] = new NodeData (i, j);
		}

		public NodeData GetNode (int x, int y)
		{
			return _data [x + y * _width];
		}
		
		public NodeData GetRandomNode ()
		{
			return GetNode (_rnd.Next (0, _width), _rnd.Next (0, _height));
		}
		
		/**
         * Gets all neighbours of specified node not processed by alghoritm.
         */
		public List<NodeData> GetNotProcessedNeighboursOf (NodeData target)
		{
			List<NodeData> neighbours = new List<NodeData> ();
			
			for (int i = 0; i < 4; i++) {
				
				int x = target.x + NodeData.DIRECTIONS [i, 0];
				int y = target.y + NodeData.DIRECTIONS [i, 1];
				
				if (IsInBounds (x, y)) {
					NodeData neighbour = GetNode (x, y);
					if (!neighbour.HasFlag (NodeData.PROCESSED))
						neighbours.Add (neighbour);
				}
			}
			return neighbours;
		}
		/**
         * Gets merged neighbours of specified node processed by alghoritm.
         */
		public List<NodeData> GetMergedNeighboursOf (NodeData target)
		{
			List<NodeData> neighbours = new List<NodeData> ();
			
			for (int i = 0; i < 4; i++) {
				
				if (!target.HasWall (i)) {
					int x = target.x + NodeData.DIRECTIONS [i, 0];
					int y = target.y + NodeData.DIRECTIONS [i, 1];
				
					if (IsInBounds (x, y)) {
						NodeData neighbour = GetNode (x, y);
						neighbours.Add (neighbour);
					}
				}
			}
			return neighbours;
		}
		
		public bool IsInBounds (int x, int y)
		{
			return ((x > -1) && (x < _width) && (y > -1) && (y < _height));
		}
		
		/**
		 * Finds a random neighbour with specified <code>processed</code> param
		 */
		
		public NodeData GetRandomNeighbour (NodeData target, bool processedNeeded)
		{
			
			int offset = _rnd.Next (0, 4);
			for (int i = 0; i < 4; i++) {
				int dir = (offset + i) % 4;
				
				int x = target.x + NodeData.DIRECTIONS [dir, 0];
				int y = target.y + NodeData.DIRECTIONS [dir, 1];
				
				if (IsInBounds (x, y)) {
					NodeData neighbour = GetNode (x, y);
					if ((neighbour.HasFlag (NodeData.PROCESSED) && processedNeeded) || (!neighbour.HasFlag (NodeData.PROCESSED) && !processedNeeded))
						return neighbour;
				}
			}
			
			return null;
		}
		
		/**
		 * Removes walls between two specified nodes
		 */
		public void Merge (NodeData from, NodeData to)
		{
			int dx = to.x - from.x;
			int dy = to.y - from.y;
			
			if (dx != 0) {
				if (dx > 0) {
					to.RemoveWall (NodeData.DIRECTION_LEFT_IDX);
					from.RemoveWall (NodeData.DIRECTION_RIGHT_IDX);
				} else {
					to.RemoveWall (NodeData.DIRECTION_RIGHT_IDX);
					from.RemoveWall (NodeData.DIRECTION_LEFT_IDX);
				}
			} else if (dy != 0) {
				if (dy > 0) {
					to.RemoveWall (NodeData.DIRECTION_DOWN_IDX);
					from.RemoveWall (NodeData.DIRECTION_UP_IDX);
				} else {
					to.RemoveWall (NodeData.DIRECTION_UP_IDX);
					from.RemoveWall (NodeData.DIRECTION_DOWN_IDX);
				}
			}
		}
		
		public NodeData GetRandomUnmergedNeighbour (NodeData target)
		{
			List<NodeData> neighbours = new List<NodeData> ();
			
			for (int directionIdx = 0; directionIdx < 4; directionIdx++) {
				
				int x = target.x + NodeData.DIRECTIONS [directionIdx, 0];
				int y = target.y + NodeData.DIRECTIONS [directionIdx, 1];
				
				if (IsInBounds (x, y)) {
					NodeData neighbour = GetNode (x, y);
										
					int opposite = directionIdx + (2 * (directionIdx > 1 ? -1 : 1));
					if (neighbour.HasWall (opposite))
						neighbours.Add (neighbour);
				}
			}

			return neighbours [_rnd.Next (0, neighbours.Count)];
		}
	}
}

